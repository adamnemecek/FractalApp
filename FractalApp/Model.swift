//
//  Model.swift
//  FractalApp
//
//  Created by Tom Briggs on 1/7/16.
//  Copyright Â© 2016 Tom Briggs. All rights reserved.
//

import Foundation
import Cocoa

/**
# Model
=======
 
Defines an application wide model as part of the MVC pattern.  The model holds the global
state of the application.  
 
As part of the revision to make the Mandelbrot model be thread-safe, the global Model was also
 made thread-safe.  Part of this included adding a new "setPixel" method that would allow the
 sending an entire row.  The pixel copying happens in a serial, high-priority dispatch queue
 (Swift's replacement for Java's synchronized methods).

*/

class Model {

    private let queueSync : dispatch_queue_t = { () -> dispatch_queue_t in
        let queueAttrs = dispatch_queue_attr_make_with_qos_class(
            DISPATCH_QUEUE_SERIAL,
            QOS_CLASS_USER_INITIATED /* Same as DISPATCH_QUEUE_PRIORITY_HIGH */,
            0
        );
        
        return dispatch_queue_create("edu.ship.thb.Model.synch",queueAttrs);
    }()
    
    private var fractalType : FractalType = FractalType.Mandelbrot

    /**
     Gets the selected fractal type
     :returns: the currently selected fractal type 
    */
    func getFractalType( ) -> FractalType { return fractalType }

    /**
     Sets the selected fractal type to one matching the given name.  The names must match
     the value names that appear in `FractalType`
     -seealso: FractalType
     :param: fractalTypeName - The name of the fractal type to select
     :returns: a Bool whether the typename was valid or not.
    */
    func setFractalType(fractalTypeName: String) -> Bool
    {
        switch(fractalTypeName) {
        case FractalType.Mandelbrot.rawValue:
            fractalType = FractalType.Mandelbrot
            return true
            
        case FractalType.Julia.rawValue :
            fractalType = FractalType.Julia
            return true
            
        case FractalType.Sierpinski.rawValue:
            fractalType = FractalType.Sierpinski
            return true

        default: return false
        }
    }
    
    /**
    Defines the default size for the image that will be generated by the fractal applications.
     The image size can be cahnged through a call to `handleWindowResize`, which *should* be
     generated by the ViewController when a window resize is detected.
    */
    static let default_size = NSSize(width: 800, height: 300)
    
    /**
    Defines the default bits per sample.  there are three samples per pixel, so this generates
    a 24-bit image.
    */
    static let bits_per_sample = 8
    
    /**
    Defines the range for the fractal space 
    */
    private var fractalRange = NSRect(x: -2, y: -1.5, width: 2.5, height: 3)
    
    func setFractalRange( range : NSRect)
    {
        dispatch_sync(queueSync, {
            self.fractalRange = range
        })
    }
    
    func getFractalRange( ) -> NSRect {
        return fractalRange
    }
    
    /**
    Defines the current size of the image window.  This is changed through a call to
    `handleWindowSize`.
    */
    private var windowSize = default_size

    func getWindowSize( ) -> NSSize
    {
        return windowSize
    }
    
    
    /**
        Defines an image representation that will be used by the model to hold the pixel data and drive
     the contents of the image for the GUI.  The imgRep is initialized fully by the constructor through
     a call to `handleWindowResize`
    */
    private var imgRep : NSBitmapImageRep!

    /**
    Defines the image that is managed by this model.  The image is backed by the `imgRep` object which
    holds the bitmap of the fractal.  The fractal paints into the imgRep, and the image uses the 
    representation as the contents of the image for repaint (or other operations)
    */
    private let image = NSImage()
    
    /**
    The zoom factor
    */
    private var zoom = Double(1.0)
    
    func getZoom( ) -> Double {
        return zoom
    }
    
    /**
     Returns an NSImage for the current fractal.  The image is backed by an internal 
     representation of image.

     :returns: an image
    */
    func getFractalImage( ) -> NSImage
    {
        return image
    }
    
    /**
    Default initializer for the model, ensures that the image and image representation are
    are initialized correctly.   Swift does not allow function calls during static initialization.
    When the image representation is first initialized (statically) and the image is created (also statically)
     They are decoupled - the image isn't connected to the representation.  Ultimately, the call to
     `handleWindowResize` will replace the statically created image object.
    */
    
    init( )
    {
        Swift.print("Model is initializing \(self)")
        handleWindowResize(Model.default_size)
    }
    

    /**
        broadcasts that the fractal has made progress.  
        - parameter progress: The fractal's progress
        - attention: The post happens in the *invoker's* thread.  Observers are responsible for dispatching to
                the main queue for GUI handling - for example:
        ````
             NSNotificationCenter.defaultCenter().addObserverForName("progress", object: nil, queue: nil, usingBlock: { notification in
             
             if ((notification.name == "progress") && (notification.object is FractalProgress)) {
             dispatch_sync(dispatch_get_main_queue()) {
             let fp = notification.object as! FractalProgress
             
             //myProgressBar.value = fp.value
             } // end dispatch
             } // end if
             })  // end block & addobserver
        ````

        -parameter progress:  the progress of the fractal generator
     */
    func makeProgress(progress: FractalProgress)
    {
     
        NSNotificationCenter.defaultCenter().postNotificationName("progress", object: progress)
 
    }

    /**
     broadcasts that the fractal has made progress.
     - parameter progress: The fractal's progress
     - attention: The broadcast happens in the *invoker's* thread
     - seealso: [Model.makeProgress]
     */
    func recordRunState(state state:RunState)
    {

        NSNotificationCenter.defaultCenter().postNotificationName("runState", object: state)

    }
    
    /**
        handles resizing the image representation (and thus the image).
        -parameter size: the new size (in pixels) of the image window
     */
    func handleWindowResize(size: NSSize)
    {
        dispatch_sync(queueSync, {
            Swift.print("Resizing image & representation: \(size)")
            
            self.windowSize = size

            if ((self.imgRep != nil) && (self.image.representations.contains(self.imgRep))) {
                self.image.removeRepresentation(self.imgRep)
            }
            
           self.imgRep = NSBitmapImageRep(bitmapDataPlanes: nil,
                    pixelsWide: Int(size.width),
                    pixelsHigh: Int(size.height),
                    bitsPerSample: 8,
                    samplesPerPixel: 3,
                    hasAlpha: false,
                    isPlanar: false,
                    colorSpaceName: NSCalibratedRGBColorSpace,
                    bytesPerRow: 0, bitsPerPixel: 0)!
                
                self.image.addRepresentation(self.imgRep)
                self.image.size = size
        })
    }
    
    /**
        Sets the pixel at (x,y) to the given color
        -parameter color: the color for the pixel
        -parameter x: the x cooridinate (in horizontal screen coordinates)
        -parameter y: the y cooridinate (in horizontal screen coordinates)
    */
    func setPixel(c color:NSColor, x: Int, y: Int)
    {
        dispatch_sync(queueSync, {
            self.imgRep.setColor(color, atX: x, y: y)
        })
    }
    
    /**
     Sets the pixel at (x,y) to the given color
     -parameter colorBuffer: the color for the pixel
     -parameter x: the x cooridinate (in horizontal screen coordinates)
     -parameter y: the y cooridinate (in horizontal screen coordinates)
     */
    func setPixel(colorBuff colorBuff:[NSColor], y: Int)
    {
        dispatch_sync(queueSync, {
            for x in 0 ..< colorBuff.count
            {
                self.imgRep.setColor(colorBuff[x], atX: x, y: y)
            }
        })
    }
    
    /**
     Sets the pixel at (x,y) to the given color. 
     also trigger the image for needs redisplay
     -parameter colorBuffer: the color for the pixel
     -parameter x: the x cooridinate (in horizontal screen coordinates)
     -parameter y: the y cooridinate (in horizontal screen coordinates)
     */
    func setPixel(colorBuff colorBuff:[NSColor], offsetX: Int, y: Int)
    {
        dispatch_sync(queueSync, {
            for x in 0 ..< colorBuff.count
            {
                self.imgRep.setColor(colorBuff[x], atX: x+offsetX, y: y)
            }
        })
    }
    
    /**
    Clears the pixel buffer 
    */
    func clearPixels( )
    {
        dispatch_sync(queueSync, {

            for y in 0 ..< Int(self.imgRep.size.height)
            {
                for x in 0 ..< Int(self.imgRep.size.width)
                {
                    self.imgRep.setColor(NSColor.clearColor(), atX: x, y: y)
                }
            }
            
        })
    }
    
    /**
        Recalculates the window size
        -parameter mangify: the magnification factor
        -todo: test this
    */
    func magnify(magnify: CGFloat)
    {
        let factor = 1.0 - magnify
        
        self.zoom = self.zoom * Double(factor)
        
        let origCenterX =  self.fractalRange.origin.x + (self.fractalRange.width/2)
        let origCenterY = self.fractalRange.origin.y + (self.fractalRange.height/2)
        
        let adjWidth = self.fractalRange.width * CGFloat(factor)
        let adjHeight = self.fractalRange.height * CGFloat(factor)
        
        let adjOriginX = origCenterX - adjWidth/2
        let adjOriginY = origCenterY - adjHeight/2
        
        let origin = CGPoint(x: adjOriginX, y: adjOriginY)
        
        let newSize = CGSize(width: adjWidth, height: adjHeight)
        self.fractalRange = NSRect(origin: origin, size: newSize)
    }

    
}


enum FractalType : String {
    
    case Mandelbrot = "Mandelbrot"
    case Julia = "Julia"
    case Sierpinski = "Sierpinksi"
    
}


class ModelFactory {
    
    private static  let defaultModel : Model = Model( )
    
    static func getModel( ) -> Model {
        Swift.print("ModelFactory: \(defaultModel) @ \(unsafeAddressOf(defaultModel))")
        
        return ModelFactory.defaultModel;
    }

}


class FractalProgress {
    var progress : Double = 0.0
    var lastLine : Int = 0
    
    init(progress: Double, lastLine:Int)
    {
        self.progress = progress
        self.lastLine = lastLine
        
    }
}

class RunState {
    enum Name {
        case STARTED
        case FINISHED
    }
    
    let state : RunState.Name
    
    init(state:RunState.Name)
    {
        self.state = state
    }
}